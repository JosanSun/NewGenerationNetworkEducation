数组的指针、指针数组

考虑数组的指针的时候我们要同时考虑类型和维数这两个属性。换一句话，就是说一个数组排除在其中存储的数值，那么可以用类型和维数来位置表示他的种类。

一维数组
在c和c++中数组的指针就是数组的起始地址（也就第一个元素的地址），而且标准文档规定数组名代表数组的地址（这是地址数值层面的数组表示）。例如：

int a[10];
int *p;
p=&a[0]//和p=a是等价的。

因为a是数组名，所以他是该数组的地址，同时因为第一个元素为a[0]，那么&a[0]也代表了该数组的地址。但是我们是不是就说一个数组名 和该数组的第一个元素的&运算是一回事呢？在一维的时候当时是的，但是在高维的时候，我们要考虑到维数给数组带来的影响。

a[10]是一个数组，a是数组名，它是一个包含10个int类型的数组类型，不是一般的指针变量噢！（虽然标准文档规定在c++中从int[]到 int*直接转换是可以的，在使用的时候似乎在函数的参数为指针的时候，我们将该数组名赋值没有任何异样），a代表数组的首地址，在数字层面和a[10] 的地址一样。这样我们就可以使用指针变量以及a来操作这个数组了。
所以我们要注意以下问题：

p[i]和a[i]都是代表该数组的第i+1个元素；
p+i和a+i代表了第i+1个元素的地址，所以我们也可以使用　*（p+I）和*（a+I）来引用对象元素；
p+1不是对于指针数量上加一，而是表示从当前的位置跳过当前指针指向类型长度的空间，对于win32的int为4byte；
多维数组
对于二维数组a[4][6];由于数组名代表数组的起始地址，所以a（第一层）和第一个元素a[0][0]地址的数字是相同的，但是意义却是不同的。 对于该数组我们可以理解为：a的一维数组（第一层），它有四个元素a[0]、a[1]、a[2]、a[3]（第二层），而每个元素又含有6个元素a[0] [0],a[0][1],a[0][2],a[0][3],a[0][4]，a[0][5]（第三层）,…到此我们终于访问到了每个元素了，这个过程我们 经历了：a->a[0]->a[0][0]；

整体来讲：a是一个4行5列的二维数组，a表示它指向的数组的首地址（第一个元素地址&a[0]）,同时a[0]指向一行，它是这个行的名字 （和该行的第一个元素的首地址相同（第一个元素为地址&a[0][0]））。所以从数字角度说：a、a[0]、&a[0][0]是相同 的，但是他们所处的层次是不同的。

既然a代表二维数组，那么a+i就表示它的第i+1个元素*（a+i）的地址，而在二维数组中
*（a+i）又指向一个数组，*（a+i）+j表示这个数组的第j+1个元素的地址，所以要访问这个元素可以使用 *（*（a+i）+j）（也就是a[i][j]）。

他们的示意图为（虚线代表不是实际存在的）：



对照这个图，如下的一些说法都是正确的（对于a[4][6]）：

a是一个数组类型，*a指向一个数组；
a+i指向一个数组；
a、*a和&a[0][0]数值相同；
a[i]+j和*（a+i）+j是同一个概念；
总结一下就是：我们对于二维指针a，他指向数组a[0，1，2，3]，使用*，可以使他降级到第二层次，这样*a就指向了第一个真正的数组。对于其他的情况我们也可以采用相同的方式，对于其他维数和类型的数组我们可以采用相类似的思想。

说到指向数组的指针，我们还可以声明一个指针变量让它指向一个数组。例如：

int （*p）[5]；
这时p就是一个指针，要指向一个含有5个int类型元素的数组，指向其他的就会出现问题。这个时候我们可以使用上面的什么东西来初始化呢？我们可以使用*a,*(a+1)，a[2]等。原因很简单：我们在一个二维的数组中，那么表达方式有上面的相互类似的意义呢？只有　*a,*(a+1)，a[2]等。

指针数组
一个指针数组是指一个数组中的每个元素都是一个指针，例如：

int *p[10];//而不能是int (*p)[10]
或者

char *p[10];
此时p是一个指针（数值上和&p[0]一样）；

 

在前面有int t[10]；

int * pt=t;//使用pt指向t

那么这里我们用什么指向int *t[10]中的t呢？我们要使用一个指针的指针：

int **pt=t;
这是因为：在int *t[10]中，每个元素是指针，那么同时t又指向这个数组，数组上和&t[0]相同，也就是指向t[0]，指向一个指针变量，可以说是一个指针的指针了，所以自然要用

int **pt;		